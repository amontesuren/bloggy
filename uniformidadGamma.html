<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uniformidad NEMA · Falken's Maze</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">

    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.2/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">

    <style>
        .page-body { max-width: 980px; }

        /* ===== UPLOAD ZONE ===== */
        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 44px 32px;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.2s, background 0.2s;
        }
        .upload-zone:hover, .upload-zone.drag-over {
            border-color: var(--accent-blue);
            background: rgba(136,192,208,0.05);
        }
        .upload-icon { font-size: 2.8rem; color: var(--text-muted); margin-bottom: 10px; }
        .upload-title { font-size: 15px; font-weight: 600; color: var(--text-secondary); margin-bottom: 5px; }
        .upload-sub   { font-size: 12px; color: var(--text-muted); }

        .file-info {
            display: none;
            margin-top: 14px;
            padding: 10px 16px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            font-size: 13px;
            color: var(--text-secondary);
        }

        /* ===== OPTIONS ===== */
        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 16px;
            margin-top: 18px;
        }

        /* ===== BUTTONS ===== */
        .btn-run {
            width: 100%;
            margin-top: 18px;
            padding: 12px;
            background: var(--accent-blue);
            color: var(--bg-primary);
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            transition: opacity 0.15s;
        }
        .btn-run:hover   { opacity: 0.85; }
        .btn-run:disabled { opacity: 0.35; cursor: not-allowed; }

        /* ===== STATUS BAR ===== */
        .status-bar {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 12px;
            padding: 9px 14px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            font-size: 13px;
            color: var(--text-muted);
            min-height: 38px;
        }

        /* ===== METRIC CARDS ===== */
        .metric-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 14px;
            margin-bottom: 20px;
        }
        .metric-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 18px;
            text-align: center;
        }
        .metric-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.7px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }
        .metric-value {
            font-size: 2rem;
            font-weight: 700;
            letter-spacing: -0.02em;
            font-variant-numeric: tabular-nums;
            color: var(--text-primary);
        }
        .metric-unit { font-size: 13px; color: var(--text-muted); }
        .metric-badge {
            display: inline-block;
            margin-top: 8px;
            padding: 3px 10px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
        }

        /* ===== IMAGE PANELS ===== */
        .images-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 14px;
            margin-bottom: 20px;
        }
        .image-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 14px;
            text-align: center;
        }
        .image-panel-label {
            font-size: 10.5px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.6px;
            color: var(--text-muted);
            margin-bottom: 10px;
        }
        .image-panel canvas {
            width: 100%;
            height: auto;
            image-rendering: pixelated;
            border-radius: 6px;
            display: block;
        }
        .image-panel-sub {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 6px;
        }

        /* ===== RESULTS TABLE ===== */
        .results-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13.5px;
        }
        .results-table th {
            background: var(--bg-tertiary);
            color: var(--text-muted);
            font-weight: 600;
            font-size: 10.5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 10px 16px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }
        .results-table td {
            padding: 11px 16px;
            border-bottom: 1px solid var(--border-sub);
            color: var(--text-secondary);
            vertical-align: middle;
        }
        .results-table tr:last-child td { border-bottom: none; }
        .results-table tr:hover td { background: rgba(255,255,255,0.02); }
        .results-table td:first-child { color: var(--text-primary); font-weight: 500; }

        .result-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            min-width: 80px;
            text-align: center;
        }
        .bg-ok   { background: rgba(163,190,140,0.15); color: var(--accent-green);  border: 1px solid rgba(163,190,140,0.3); }
        .bg-fail { background: rgba(191,97,106,0.15);  color: var(--accent-red);    border: 1px solid rgba(191,97,106,0.3); }

        /* ===== REFERENCE NOTE ===== */
        .ref-note {
            margin-top: 16px;
            padding: 11px 16px;
            background: rgba(136,192,208,0.06);
            border-left: 3px solid var(--accent-blue);
            border-radius: 0 8px 8px 0;
            font-size: 12px;
            color: var(--text-muted);
            line-height: 1.6;
        }

        /* ===== SPINNER ===== */
        .spinner {
            display: inline-block;
            width: 14px; height: 14px;
            border: 2px solid var(--border);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 0.75s linear infinite;
            flex-shrink: 0;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* ===== RESPONSIVE ===== */
        @media (max-width: 768px) {
            .metric-grid  { grid-template-columns: repeat(2, 1fr); }
            .images-grid  { grid-template-columns: 1fr; }
        }
        @media (max-width: 480px) {
            .metric-grid  { grid-template-columns: 1fr 1fr; }
        }
    </style>
</head>
<body>

<main class="main-content">
<div class="page-body">

    <!-- Header -->
    <div class="page-header">
        <div class="page-icon"><i class="bi bi-grid-1x2-fill"></i></div>
        <h1 class="page-title">Uniformidad Intrínseca NEMA</h1>
        <p class="page-subtitle">Prueba NEMA NU 1 — Uniformidad Integral y Diferencial de gammacámara · Flood intrínseco</p>
    </div>

    <!-- Upload + Options card -->
    <div class="calc-card" style="margin-bottom:20px;">

        <input type="file" id="fileInput" accept=".dcm,.dicom,application/dicom" style="display:none;">

        <div class="upload-zone" id="uploadZone">
            <div class="upload-icon"><i class="bi bi-file-medical"></i></div>
            <div class="upload-title">Arrastra el archivo DICOM aquí</div>
            <div class="upload-sub">o haz clic para seleccionar &nbsp;·&nbsp; Flood intrínseco (.dcm)</div>
        </div>

        <div class="file-info" id="fileInfo">
            <i class="bi bi-file-earmark-check" style="color:var(--accent-green);margin-right:6px;"></i>
            <span id="fileInfoText"></span>
        </div>

        <div class="options-grid">
            <div>
                <label class="field-label">Frame DICOM</label>
                <select id="frameSelect" class="dark-select" disabled>
                    <option value="0">Frame 1</option>
                </select>
            </div>
            <div>
                <label class="field-label">Resolución análisis</label>
                <select id="resamplePreset" class="dark-select">
                    <option value="64">64 × 64 px</option>
                    <option value="78" selected>78 × 78 px</option>
                    <option value="128">128 × 128 px</option>
                    <option value="0">Sin remuestreo</option>
                </select>
            </div>
        </div>

        <button id="btnRun" class="btn-run" disabled>
            <i class="bi bi-play-fill"></i>&nbsp; Calcular Uniformidad NEMA
        </button>

        <div class="status-bar" id="statusBar">
            <i class="bi bi-info-circle"></i>
            <span>Carga un archivo DICOM de flood intrínseco para comenzar</span>
        </div>
    </div>

    <!-- Results (hidden until calculation) -->
    <div id="resultsSection" style="display:none;">

        <!-- 4 metric cards -->
        <div class="metric-grid">
            <div class="metric-card">
                <div class="metric-label">IU &mdash; UFOV</div>
                <div class="metric-value" id="valIUufov">—</div>
                <div class="metric-unit">%</div>
                <div id="badgeIUufov" class="metric-badge">—</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">IU &mdash; CFOV</div>
                <div class="metric-value" id="valIUcfov">—</div>
                <div class="metric-unit">%</div>
                <div id="badgeIUcfov" class="metric-badge">—</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">DU &mdash; UFOV</div>
                <div class="metric-value" id="valDUufov">—</div>
                <div class="metric-unit">%</div>
                <div id="badgeDUufov" class="metric-badge">—</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">DU &mdash; CFOV</div>
                <div class="metric-value" id="valDUcfov">—</div>
                <div class="metric-unit">%</div>
                <div id="badgeDUcfov" class="metric-badge">—</div>
            </div>
        </div>

        <!-- Image displays -->
        <div class="images-grid">
            <div class="image-panel">
                <div class="image-panel-label"><i class="bi bi-image"></i>&nbsp; Imagen original</div>
                <canvas id="canvasOrig"></canvas>
                <div class="image-panel-sub" id="subOrig"></div>
            </div>
            <div class="image-panel">
                <div class="image-panel-label"><i class="bi bi-bounding-box"></i>&nbsp; UFOV</div>
                <canvas id="canvasUFOV"></canvas>
                <div class="image-panel-sub" id="subUFOV">Campo de visión útil completo</div>
            </div>
            <div class="image-panel">
                <div class="image-panel-label"><i class="bi bi-bounding-box-circles"></i>&nbsp; CFOV (75 %)</div>
                <canvas id="canvasCFOV"></canvas>
                <div class="image-panel-sub" id="subCFOV">75 % central del UFOV</div>
            </div>
        </div>

        <!-- Detailed results table -->
        <div class="calc-card">
            <div style="font-size:12px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--text-muted);margin-bottom:16px;">
                Resultados detallados
            </div>
            <table class="results-table">
                <thead>
                    <tr>
                        <th>Parámetro</th>
                        <th>Región</th>
                        <th>Valor</th>
                        <th>Límite ref.</th>
                        <th>Estado</th>
                    </tr>
                </thead>
                <tbody id="resultsBody"></tbody>
            </table>

            <div class="ref-note">
                <strong style="color:var(--text-secondary);">Referencias NEMA NU 1-2012:</strong>
                Límites típicos de aceptación clínica:
                IU UFOV ≤ 5,0 % &nbsp;·&nbsp; IU CFOV ≤ 3,5 % &nbsp;·&nbsp; DU UFOV ≤ 3,0 % &nbsp;·&nbsp; DU CFOV ≤ 2,5 %.
                Los píxeles en azul oscuro en las imágenes corresponden a la región enmascarada (excluida del análisis).
                Verificar con los criterios del fabricante y el protocolo local de control de calidad.
            </div>
        </div>

    </div><!-- /resultsSection -->

</div>
</main>

<!-- dicom-parser must load before inline script -->
<script src="https://unpkg.com/dicom-parser@1.8.21/dist/dicomParser.js"></script>
<script src="nav.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.2/js/bootstrap.bundle.min.js"></script>

<script>
// ============================================================
//  DICOM PARSING
// ============================================================
var parsedDICOM = null;

function parseDICOM(arrayBuffer) {
    var byteArray = new Uint8Array(arrayBuffer);
    var dataSet = dicomParser.parseDicom(byteArray);

    var rows             = dataSet.uint16('x00280010');
    var cols             = dataSet.uint16('x00280011');
    var bitsAllocated    = dataSet.uint16('x00280100') || 16;
    var pixelRepresent   = dataSet.uint16('x00280103') || 0;
    var numFramesStr     = dataSet.string('x00280008');
    var numFrames        = numFramesStr ? parseInt(numFramesStr, 10) : 1;

    var pixelEl = dataSet.elements.x7fe00010;
    if (!pixelEl) throw new Error('No se encontraron datos de píxel (tag 7FE0,0010)');

    var offset      = pixelEl.dataOffset;
    var framePixels = rows * cols;
    var bpp         = bitsAllocated / 8;

    // Helper: create aligned typed array (handles unaligned DICOM offsets)
    function typedView(Type, byteOff, len) {
        var es = Type.BYTES_PER_ELEMENT;
        if (byteOff % es === 0) return new Type(arrayBuffer, byteOff, len);
        var src = new Uint8Array(arrayBuffer, byteOff, len * es);
        var buf = new ArrayBuffer(len * es);
        new Uint8Array(buf).set(src);
        return new Type(buf, 0, len);
    }

    var TypedArr = bitsAllocated === 8  ? Uint8Array  :
                   bitsAllocated === 32 ? (pixelRepresent ? Int32Array : Uint32Array) :
                                          (pixelRepresent ? Int16Array  : Uint16Array);

    var frames = [];
    for (var f = 0; f < numFrames; f++) {
        var fOff = offset + f * framePixels * bpp;
        var raw  = typedView(TypedArr, fOff, framePixels);
        var data = new Float64Array(framePixels);
        for (var i = 0; i < framePixels; i++) data[i] = raw[i];
        frames.push(data);
    }

    return { frames: frames, rows: rows, cols: cols, numFrames: numFrames };
}

// ============================================================
//  NEMA NU 1 ALGORITHMS  (JavaScript port of the Python code)
// ============================================================

/** Mean of unmasked pixels (mask[i]=1 → excluded) */
function maskedMean(data, mask, n) {
    var sum = 0, count = 0;
    for (var i = 0; i < n; i++) if (!mask[i]) { sum += data[i]; count++; }
    return count > 0 ? sum / count : 0;
}

/**
 * Block-reduce with SUM, matching skimage.measure.block_reduce(func=np.sum).
 * Block size = floor(rows/targetRows), output size = ceil(rows/blockSize).
 */
function blockReduce(data, rows, cols, targetRows, targetCols) {
    var bR = Math.floor(rows / targetRows);
    var bC = Math.floor(cols / targetCols);
    var oR = Math.ceil(rows / bR);
    var oC = Math.ceil(cols / bC);
    var out = new Float64Array(oR * oC);
    for (var tr = 0; tr < oR; tr++) {
        for (var tc = 0; tc < oC; tc++) {
            var sum = 0;
            for (var br = 0; br < bR; br++) {
                for (var bc = 0; bc < bC; bc++) {
                    var r = tr * bR + br, c = tc * bC + bc;
                    if (r < rows && c < cols) sum += data[r * cols + c];
                }
            }
            out[tr * oC + tc] = sum;
        }
    }
    return { data: out, rows: oR, cols: oC };
}

/**
 * 9-point NEMA smoothing kernel [[1,2,1],[2,4,2],[1,2,1]] / 16
 * Boundary mode: reflect (matches scipy.ndimage.convolve default)
 */
function nemaSmooth(data, rows, cols) {
    var k = [[1,2,1],[2,4,2],[1,2,1]];
    var out = new Float64Array(rows * cols);
    for (var r = 0; r < rows; r++) {
        for (var c = 0; c < cols; c++) {
            var val = 0;
            for (var dr = -1; dr <= 1; dr++) {
                for (var dc = -1; dc <= 1; dc++) {
                    var rr = r + dr, cc = c + dc;
                    // reflect at borders
                    if (rr < 0)    rr = 1;
                    else if (rr >= rows) rr = rows - 2;
                    if (cc < 0)    cc = 1;
                    else if (cc >= cols) cc = cols - 2;
                    val += data[rr * cols + cc] * k[dr + 1][dc + 1];
                }
            }
            out[r * cols + c] = val / 16;
        }
    }
    return out;
}

/** Bounding box of unmasked pixels: returns {minR, maxR, minC, maxC} */
function boundingBox(mask, rows, cols) {
    var minR = rows, maxR = 0, minC = cols, maxC = 0;
    for (var r = 0; r < rows; r++) {
        for (var c = 0; c < cols; c++) {
            if (!mask[r * cols + c]) {
                if (r < minR) minR = r;
                if (r > maxR) maxR = r;
                if (c < minC) minC = c;
                if (c > maxC) maxC = c;
            }
        }
    }
    return { minR: minR, maxR: maxR, minC: minC, maxC: maxC };
}

/**
 * Create CFOV mask (inner 75 % of UFOV bounding box).
 * Implements the NEMA "≥50 % area inside CFOV" pixel inclusion rule
 * using the ceil/floor coordinate transform from the Python code.
 */
function createCFOV(ufovMask, rows, cols) {
    var bb = boundingBox(ufovMask, rows, cols);
    var fUL_r = bb.minR - 0.5, fUL_c = bb.minC - 0.5;
    var fLR_r = bb.maxR + 0.5, fLR_c = bb.maxC + 0.5;
    var fCr   = (fUL_r + fLR_r) / 2, fCc = (fUL_c + fLR_c) / 2;

    var UL_r = Math.ceil(0.25 * fCr + 0.75 * fUL_r - 0.5);
    var UL_c = Math.ceil(0.25 * fCc + 0.75 * fUL_c - 0.5);
    var LR_r = Math.floor(0.25 * fCr + 0.75 * fLR_r - 0.5);
    var LR_c = Math.floor(0.25 * fCc + 0.75 * fLR_c - 0.5);

    var mask = new Uint8Array(rows * cols).fill(1); // all masked
    for (var r = Math.max(0, UL_r); r <= Math.min(rows - 1, LR_r); r++)
        for (var c = Math.max(0, UL_c); c <= Math.min(cols - 1, LR_c); c++)
            mask[r * cols + c] = 0; // unmask CFOV rectangle
    return mask;
}

/**
 * 4-connected binary dilation of mask (matches scipy.ndimage default structure).
 * Expands the excluded region by 1 pixel in the 4 cardinal directions.
 */
function binaryDilate(mask, rows, cols) {
    var out = new Uint8Array(mask);
    for (var r = 0; r < rows; r++) {
        for (var c = 0; c < cols; c++) {
            if (mask[r * cols + c]) {
                if (r > 0)       out[(r - 1) * cols + c] = 1;
                if (r < rows-1)  out[(r + 1) * cols + c] = 1;
                if (c > 0)       out[r * cols + c - 1]   = 1;
                if (c < cols-1)  out[r * cols + c + 1]   = 1;
            }
        }
    }
    return out;
}

/** Integral Uniformity: (max − min) / (max + min) over unmasked pixels */
function unifCalc(data, mask, n) {
    var mn = Infinity, mx = -Infinity;
    for (var i = 0; i < n; i++) {
        if (!mask[i]) {
            if (data[i] < mn) mn = data[i];
            if (data[i] > mx) mx = data[i];
        }
    }
    if (!isFinite(mn) || mn + mx <= 0) return 0;
    return (mx - mn) / (mx + mn);
}

/**
 * Differential Uniformity: sliding window of 5 consecutive pixels in
 * vertical and horizontal directions, finds the group with maximum contrast.
 * Returns max DU in each direction and the position of that group.
 */
function diffData(data, mask, rows, cols) {
    var maxV = 0, maxH = 0, posV = [0,0], posH = [0,0];

    // Vertical windows (5 consecutive rows, same column)
    for (var r = 0; r <= rows - 5; r++) {
        for (var c = 0; c < cols; c++) {
            var bad = false, mn = Infinity, mx = -Infinity;
            for (var dr = 0; dr < 5; dr++) {
                var idx = (r + dr) * cols + c;
                if (mask[idx]) { bad = true; break; }
                if (data[idx] < mn) mn = data[idx];
                if (data[idx] > mx) mx = data[idx];
            }
            if (!bad && mn + mx > 0) {
                var du = 100 * (mx - mn) / (mx + mn);
                if (du > maxV) { maxV = du; posV = [r, c]; }
            }
        }
    }

    // Horizontal windows (5 consecutive cols, same row)
    for (var r = 0; r < rows; r++) {
        for (var c = 0; c <= cols - 5; c++) {
            var bad = false, mn = Infinity, mx = -Infinity;
            for (var dc = 0; dc < 5; dc++) {
                var idx = r * cols + (c + dc);
                if (mask[idx]) { bad = true; break; }
                if (data[idx] < mn) mn = data[idx];
                if (data[idx] > mx) mx = data[idx];
            }
            if (!bad && mn + mx > 0) {
                var du = 100 * (mx - mn) / (mx + mn);
                if (du > maxH) { maxH = du; posH = [r, c]; }
            }
        }
    }

    return { maxVert: maxV, maxHoriz: maxH, vertPos: posV, horizPos: posH };
}

/**
 * Full NEMA preprocessing pipeline:
 *  1) Block-reduce to targetSize × targetSize
 *  2) 9-point NEMA smooth
 *  3) UFOV: pixels > 75 % of CFOV mean (NEMA step 1)
 *  4) Dilate UFOV mask by 1 px (NEMA step 2)
 *  5) CFOV: inner 75 % of dilated UFOV bounding box
 */
function nemaPreprocess(rawData, rows, cols, targetSize) {
    var data, R, C;
    if (targetSize > 0) {
        var reduced = blockReduce(rawData, rows, cols, targetSize, targetSize);
        data = reduced.data; R = reduced.rows; C = reduced.cols;
    } else {
        data = rawData.slice(); R = rows; C = cols;
    }

    var N = R * C;
    data = nemaSmooth(data, R, C);

    // Pass 1: UFOV using whole-image mean as threshold
    var allUnmasked = new Uint8Array(N);
    var thresh1 = maskedMean(data, allUnmasked, N);
    var ufov1 = new Uint8Array(N);
    for (var i = 0; i < N; i++) ufov1[i] = data[i] < thresh1 ? 1 : 0;

    // Pass 2: refine using 0.75 × CFOV mean
    var cfov1    = createCFOV(ufov1, R, C);
    var cfovMean = maskedMean(data, cfov1, N);
    var ufov2 = new Uint8Array(N);
    for (var i = 0; i < N; i++) ufov2[i] = data[i] < 0.75 * cfovMean ? 1 : 0;

    // Dilate mask (shrink FOV border by 1 pixel)
    var ufovFinal = binaryDilate(ufov2, R, C);
    var cfovFinal = createCFOV(ufovFinal, R, C);

    return { data: data, rows: R, cols: C, ufovMask: ufovFinal, cfovMask: cfovFinal };
}

/** Main entry point — returns all uniformity metrics and image data */
function calculateNEMA(rawData, rows, cols, targetSize) {
    var pp = nemaPreprocess(rawData, rows, cols, targetSize);
    var N  = pp.rows * pp.cols;

    var IUufov = 100 * unifCalc(pp.data, pp.ufovMask, N);
    var IUcfov = 100 * unifCalc(pp.data, pp.cfovMask, N);
    var duU    = diffData(pp.data, pp.ufovMask, pp.rows, pp.cols);
    var duC    = diffData(pp.data, pp.cfovMask, pp.rows, pp.cols);

    return {
        IUufov:      IUufov,
        IUcfov:      IUcfov,
        DUvertUfov:  duU.maxVert,
        DUhorizUfov: duU.maxHoriz,
        DUvertCfov:  duC.maxVert,
        DUhorizCfov: duC.maxHoriz,
        vertPosU:    duU.vertPos,
        horizPosU:   duU.horizPos,
        vertPosC:    duC.vertPos,
        horizPosC:   duC.horizPos,
        data:        pp.data,
        ufovMask:    pp.ufovMask,
        cfovMask:    pp.cfovMask,
        rows:        pp.rows,
        cols:        pp.cols
    };
}

// ============================================================
//  CANVAS RENDERING  (hot colormap: black→red→yellow→white)
// ============================================================
function hotColor(t) {
    return [
        Math.min(255, Math.round(t * 3 * 255)),
        Math.min(255, Math.max(0, Math.round((t * 3 - 1) * 255))),
        Math.min(255, Math.max(0, Math.round((t * 3 - 2) * 255)))
    ];
}

function renderCanvas(canvas, data, mask, rows, cols) {
    canvas.width  = cols;
    canvas.height = rows;
    var ctx = canvas.getContext('2d');
    var img = ctx.createImageData(cols, rows);

    var mn = Infinity, mx = -Infinity;
    for (var i = 0; i < rows * cols; i++) {
        if (!mask || !mask[i]) {
            if (data[i] < mn) mn = data[i];
            if (data[i] > mx) mx = data[i];
        }
    }

    for (var i = 0; i < rows * cols; i++) {
        var r, g, b;
        if (mask && mask[i]) {
            r = 20; g = 40; b = 80;  // masked → dark blue
        } else {
            var t = mx > mn ? (data[i] - mn) / (mx - mn) : 0;
            var rgb = hotColor(t);
            r = rgb[0]; g = rgb[1]; b = rgb[2];
        }
        img.data[i*4]   = r;
        img.data[i*4+1] = g;
        img.data[i*4+2] = b;
        img.data[i*4+3] = 255;
    }
    ctx.putImageData(img, 0, 0);
}

// ============================================================
//  UI HELPERS
// ============================================================
var LIMITS = { IUufov: 5.0, IUcfov: 3.5, DUufov: 3.0, DUcfov: 2.5 };

function setStatus(msg, loading) {
    var bar = document.getElementById('statusBar');
    bar.innerHTML = loading
        ? '<span class="spinner"></span><span>' + msg + '</span>'
        : '<i class="bi bi-info-circle"></i><span>' + msg + '</span>';
}

function applyBadge(elId, value, limit) {
    var el  = document.getElementById(elId);
    var ok  = value <= limit;
    el.textContent = ok ? '✓ Conforme' : '✗ No conforme';
    el.className   = 'metric-badge ' + (ok ? 'bg-ok' : 'bg-fail');
}

function badgeCell(value, limit) {
    var ok  = value <= limit;
    var cls = ok ? 'bg-ok' : 'bg-fail';
    return '<span class="result-badge ' + cls + '">' + (ok ? 'Conforme' : 'No conforme') + '</span>';
}

function fillResults(res) {
    var DUufov = Math.max(res.DUvertUfov, res.DUhorizUfov);
    var DUcfov = Math.max(res.DUvertCfov, res.DUhorizCfov);

    // Metric cards
    document.getElementById('valIUufov').textContent = res.IUufov.toFixed(2);
    document.getElementById('valIUcfov').textContent = res.IUcfov.toFixed(2);
    document.getElementById('valDUufov').textContent = DUufov.toFixed(2);
    document.getElementById('valDUcfov').textContent = DUcfov.toFixed(2);

    applyBadge('badgeIUufov', res.IUufov,  LIMITS.IUufov);
    applyBadge('badgeIUcfov', res.IUcfov,  LIMITS.IUcfov);
    applyBadge('badgeDUufov', DUufov,       LIMITS.DUufov);
    applyBadge('badgeDUcfov', DUcfov,       LIMITS.DUcfov);

    // Detail table rows
    var rows = [
        { param: 'Uniformidad Integral (IU)',           region: 'UFOV',       val: res.IUufov,      limit: LIMITS.IUufov },
        { param: 'Uniformidad Integral (IU)',           region: 'CFOV (75 %)', val: res.IUcfov,      limit: LIMITS.IUcfov },
        { param: 'Uniformidad Diferencial — vertical',  region: 'UFOV',       val: res.DUvertUfov,  limit: LIMITS.DUufov },
        { param: 'Uniformidad Diferencial — horizontal',region: 'UFOV',       val: res.DUhorizUfov, limit: LIMITS.DUufov },
        { param: 'Uniformidad Diferencial — vertical',  region: 'CFOV (75 %)', val: res.DUvertCfov,  limit: LIMITS.DUcfov },
        { param: 'Uniformidad Diferencial — horizontal',region: 'CFOV (75 %)', val: res.DUhorizCfov, limit: LIMITS.DUcfov }
    ];

    document.getElementById('resultsBody').innerHTML = rows.map(function(row) {
        return '<tr>' +
            '<td>' + row.param + '</td>' +
            '<td style="color:var(--text-muted);font-size:12px;">' + row.region + '</td>' +
            '<td style="font-variant-numeric:tabular-nums;font-weight:600;color:var(--text-primary);">' +
                row.val.toFixed(2) + ' %</td>' +
            '<td style="color:var(--text-muted);">&le; ' + row.limit.toFixed(1) + ' %</td>' +
            '<td>' + badgeCell(row.val, row.limit) + '</td>' +
            '</tr>';
    }).join('');
}

// ============================================================
//  EVENT HANDLERS
// ============================================================
var fileInput    = document.getElementById('fileInput');
var uploadZone   = document.getElementById('uploadZone');
var btnRun       = document.getElementById('btnRun');
var frameSelect  = document.getElementById('frameSelect');

uploadZone.addEventListener('click', function() { fileInput.click(); });

uploadZone.addEventListener('dragover', function(e) {
    e.preventDefault();
    uploadZone.classList.add('drag-over');
});
uploadZone.addEventListener('dragleave', function() {
    uploadZone.classList.remove('drag-over');
});
uploadZone.addEventListener('drop', function(e) {
    e.preventDefault();
    uploadZone.classList.remove('drag-over');
    if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
});
fileInput.addEventListener('change', function() {
    if (fileInput.files[0]) handleFile(fileInput.files[0]);
});

function handleFile(file) {
    setStatus('Leyendo archivo DICOM…', true);
    var reader = new FileReader();
    reader.onload = function(e) {
        try {
            parsedDICOM = parseDICOM(e.target.result);

            // Show file info
            var info = document.getElementById('fileInfo');
            info.style.display = 'block';
            document.getElementById('fileInfoText').textContent =
                file.name + '  ·  ' +
                parsedDICOM.rows + ' × ' + parsedDICOM.cols + ' px  ·  ' +
                parsedDICOM.numFrames + ' frame' + (parsedDICOM.numFrames > 1 ? 's' : '');

            // Populate frame selector
            frameSelect.innerHTML = '';
            for (var f = 0; f < parsedDICOM.numFrames; f++) {
                var opt = document.createElement('option');
                opt.value = f;
                opt.textContent = 'Frame ' + (f + 1);
                frameSelect.appendChild(opt);
            }
            frameSelect.disabled = parsedDICOM.numFrames <= 1;

            btnRun.disabled = false;
            setStatus('DICOM cargado correctamente. Ajusta las opciones y pulsa Calcular.', false);
        } catch (err) {
            setStatus('Error al parsear el DICOM: ' + err.message, false);
            btnRun.disabled = true;
        }
    };
    reader.onerror = function() {
        setStatus('Error al leer el archivo.', false);
    };
    reader.readAsArrayBuffer(file);
}

btnRun.addEventListener('click', function() {
    if (!parsedDICOM) return;

    var frame      = parseInt(frameSelect.value, 10) || 0;
    var targetSize = parseInt(document.getElementById('resamplePreset').value, 10);
    var rawData    = parsedDICOM.frames[frame];

    setStatus('Calculando uniformidad NEMA…', true);
    btnRun.disabled = true;

    // setTimeout allows the browser to repaint before heavy computation
    setTimeout(function() {
        try {
            var res = calculateNEMA(rawData, parsedDICOM.rows, parsedDICOM.cols, targetSize);

            // Render images
            renderCanvas(
                document.getElementById('canvasOrig'),
                rawData, null,
                parsedDICOM.rows, parsedDICOM.cols
            );
            renderCanvas(
                document.getElementById('canvasUFOV'),
                res.data, res.ufovMask,
                res.rows, res.cols
            );
            renderCanvas(
                document.getElementById('canvasCFOV'),
                res.data, res.cfovMask,
                res.rows, res.cols
            );

            // Image subtitles
            document.getElementById('subOrig').textContent =
                parsedDICOM.rows + ' × ' + parsedDICOM.cols + ' px · frame ' + (frame + 1);

            // Fill metrics and table
            fillResults(res);

            document.getElementById('resultsSection').style.display = '';
            setStatus('Cálculo completado · ' + res.rows + ' × ' + res.cols + ' px tras remuestreo.', false);
        } catch (err) {
            setStatus('Error durante el cálculo: ' + err.message, false);
            console.error(err);
        }
        btnRun.disabled = false;
    }, 50);
});
</script>
</body>
</html>
